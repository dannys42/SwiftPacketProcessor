{"metadata":{"title":"UTF-8 to String Converter","categoryPathComponent":"Tutorial-TOC","role":"project","category":"Tutorials"},"hierarchy":{"modules":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Reading-log-files","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Define-the-Packet"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Setup-the-Packet-Processor"}]}]},{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Processing-messages-from-sockets","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#WebSocket"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#Raw-sockets"}]}]},{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Converting-UTF-8-byte-streams-to-Strings","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#The-naive-way"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#Processing-a-stream"}]}]}],"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","paths":[["doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/$volume","doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Converting-UTF-8-byte-streams-to-Strings"]]},"schemaVersion":{"major":0,"minor":2,"patch":0},"kind":"project","identifier":{"url":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","interfaceLanguage":"swift"},"sections":[{"kind":"hero","title":"UTF-8 to String Converter","chapter":"Converting UTF-8 byte streams to Strings","estimatedTimeInMinutes":15,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"High Memory - If loading from a very large file, this could take a lot of memory and time before being able to render anything on-screen."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Latency - If reading a stream of bytes from a network socket, there may be occasions where you want to render partial data to the screen without having to wait until the full content is loaded."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While we’ll still rely on Swift’s built-in "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":" function, using the packet processor will resolve these issues by allowing us to convert any valid data we have to strings and render it on-the-fly with much lower memory and latency."}]}]},{"kind":"tasks","tasks":[{"anchor":"The-naive-way","title":"The naive way","contentSection":[{"kind":"contentAndMedia","content":[],"mediaPosition":"trailing"}],"stepsSection":[{"code":"datapacket-utf8-01-01","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We start out by defining "},{"type":"codeVoice","code":"UTF8ToString"},{"type":"text","text":" as a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/DataPacket"},{"type":"text","text":", since we are expecting to push blocks of "},{"type":"codeVoice","code":"Data"},{"type":"text","text":" into the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/PacketProcessor"},{"type":"text","text":"."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"datapacket-utf8-01-02","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Simply passing the "},{"type":"codeVoice","code":"Data"},{"type":"text","text":" into "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":" does not work since UTF-8 has variable-length characters.  If "},{"type":"codeVoice","code":"Data"},{"type":"text","text":" has split any of the characters, then "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":" will return nil and no conversion will happen."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Clearly we need to do more in order to properly process UTF-8."}]}],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"Processing-a-stream","title":"Processing a stream","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A more complete implementation.  We’ll still rely on "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":" to do the heavy lifting of actually converting UTF-8 to Strings, however we need to do some bookkeeping to ensure we handle partial data appropriately."}]}],"mediaPosition":"trailing"}],"stepsSection":[{"code":"datapacket-utf8-02-01","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We start by creating some book keeping variables.  "},{"type":"codeVoice","code":"Range"},{"type":"text","text":" will be used to keep track of range of "},{"type":"codeVoice","code":"Data.Index"},{"type":"text","text":"es."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"datapacket-utf8-02-02","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ll be creating a state machine, so let’s define a few states."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"datapacket-utf8-02-03","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create the state machine."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"datapacket-utf8-02-04","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Next we must ensure we properly handle “end” conditions correctly if we’re expecting more information."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"datapacket-utf8-02-05","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally we return the packet as well as the number of bytes consumed."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]}]}],"references":{"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile#Define-the-Packet":{"role":"pseudoSymbol","title":"Define the Packet","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Define-the-Packet","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-logfile#Define-the-Packet"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8#Processing-a-stream":{"role":"pseudoSymbol","title":"Processing a stream","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#Processing-a-stream","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/datapacket-utf8#Processing-a-stream"},"doc://PacketProcessor/documentation/PacketProcessor":{"role":"collection","title":"PacketProcessor","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" takes care of buffer management when processing packetized data within streams."}],"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor","kind":"symbol","type":"topic","url":"\/documentation\/packetprocessor"},"doc://PacketProcessor/tutorials/Tutorial-TOC/Reading-log-files":{"role":"article","title":"Reading log files","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Reading-log-files","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/reading-log-files"},"datapacket-utf8-02-01":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/\/ A buffer to append valid converted `String`s until we're ready to return","        var string = \"\"","","        \/\/\/ The last `Data.Index` that was converted to string","        var lastConsumedIndex: Data.Index!","","        \/\/\/ Invalid bytes found will generate a UTF-8 Replacement character","        let invalidCharacter = \"�\"","","        \/\/\/ A container to keep track of a range of indexes into `Data`","        struct Range {","            let startIndex: Data.Index","            let endIndex: Data.Index","","            init(startIndex: Data.Index, endIndex: Data.Index) {","                self.startIndex = startIndex","                self.endIndex = endIndex","            }","","            init(index: Data.Index) {","                self.startIndex = index","                self.endIndex = index","            }","","            func incrementEnd() -> Range {","                return Range(startIndex: self.startIndex, endIndex: self.endIndex+1)","            }","        }","","        \/\/\/ TBD","        return nil","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-02-01","type":"file","fileType":"swift","highlights":[]},"doc://PacketProcessor/documentation/PacketProcessor/DataPacket":{"role":"symbol","title":"DataPacket","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DataPacket"}],"abstract":[{"type":"text","text":"Byte-oriented packets should conform to "},{"type":"codeVoice","code":"DataPacket"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Examples of this include IP, TCP, and UDP."}],"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/DataPacket","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DataPacket"}],"url":"\/documentation\/packetprocessor\/datapacket"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8#The-naive-way":{"role":"pseudoSymbol","title":"The naive way","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#The-naive-way","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/datapacket-utf8#The-naive-way"},"datapacket-utf8-01-02":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        guard let string = String(data: data, encoding: .utf8) else {","            return nil","        }","        let packet = UTF8ToString(string: string)","        return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: data.count)","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-01-02","type":"file","fileType":"swift","highlights":[{"line":19},{"line":20},{"line":21},{"line":22},{"line":23}]},"datapacket-utf8-02-03":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/\/ A buffer to append valid converted `String`s until we're ready to return","        var string = \"\"","","        \/\/\/ The last `Data.Index` that was converted to string","        var lastConsumedIndex: Data.Index!","","        \/\/\/ Invalid bytes found will generate a UTF-8 Replacement character","        let invalidCharacter = \"�\"","","        \/\/\/ A container to keep track of a range of indexes into `Data`","        struct Range {","            let startIndex: Data.Index","            let endIndex: Data.Index","","            init(startIndex: Data.Index, endIndex: Data.Index) {","                self.startIndex = startIndex","                self.endIndex = endIndex","            }","","            init(index: Data.Index) {","                self.startIndex = index","                self.endIndex = index","            }","","            func incrementEnd() -> Range {","                return Range(startIndex: self.startIndex, endIndex: self.endIndex+1)","            }","        }","","        enum State {","            \/\/\/ range keeps track of a run of \"good\" bytes that can be converted and appended to ``string``","            case good(range: Range)","","            \/\/\/ goodRange is the last \"good\" range that has not yet been appended to ``string``.","            \/\/\/ partialRange keeps track of the start and current index of a multi-byte character","            case partial(goodRange: Range, partialRange: Range, count: Int)","","            \/\/\/ an exit condition if we were expecting more bytes in a multi-byte character, but ran out","            case incomplete(lastGoodIndex: Data.Index)","","            \/\/\/ an exit condition when everything has been properly converted","            case done(lastGoodIndex: Data.Index)","        }","","        var state = State.good(range: .init(index: data.startIndex))","        var isDone = false","","        while !isDone {","            let nextState: State","            switch state {","            case .good(range: let range):","                \/\/ The logic here is:","                \/\/ - Extend the range while we have valid bytes","                \/\/ - Handle invalid characters","                \/\/ - Move to the `partial` state when we detect a multi-byte character","                \/\/ - Convert validated bytes if we reach the end of the buffer","                guard range.endIndex < data.endIndex else {","                    if range.startIndex < range.endIndex {","                        let goodData = data[range.startIndex..<data.endIndex]","                        string.append(String(data: goodData, encoding: .utf8)!)","                    }","                    nextState = .done(lastGoodIndex: data.endIndex)","                    break","                }","                let byte = data[range.endIndex]","                let nextIndex = range.endIndex + 1","                if (byte & 0b1000_0000) == 0b0000_0000 {","                    nextState = .good(range: range.incrementEnd())","                } else if (byte & 0b1110_0000) == 0b1100_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 1)","                } else if (byte & 0b1111_0000) == 0b1110_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 2)","                } else if (byte & 0b1111_1000) == 0b1111_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 3)","                } else if (byte & 0b1111_1100) == 0b1111_1000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 4)","                } else if (byte & 0b1111_1110) == 0b1111_1100 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 5)","                } else {","                    let goodData = data[range.startIndex..<range.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: nextIndex))","                }","            case .partial(goodRange: let goodRange, partialRange: let partialRange, count: let count):","                \/\/ The logic here is:","                \/\/ - Validate each byte in a multi-byte character","                \/\/ - Handle invalid characters","                \/\/ - Go to `incomplete` state if we have fewer bytes than expected","                \/\/ - Go to `good` state if we've validated all the bytes of the multi-byte character","                ","                guard count > 0 else {","                    nextState = .good(range: Range(startIndex: goodRange.startIndex, endIndex: partialRange.endIndex))","                    break","                }","                guard partialRange.endIndex < data.endIndex else {","                    nextState = .incomplete(lastGoodIndex: partialRange.startIndex-1)","                    break","                }","                let byte = data[partialRange.endIndex]","                if (byte & 0b1100_0000) == 0b1000_0000 {","                    nextState = .partial(goodRange: goodRange, partialRange: partialRange.incrementEnd(), count: count-1)","                } else {","                    let goodData = data[goodRange.startIndex..<goodRange.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: partialRange.endIndex+1))","                }","            case .incomplete(lastGoodIndex: let index):","                lastConsumedIndex = index","                nextState = state","                isDone = true","            case .done(lastGoodIndex: let index):","                lastConsumedIndex = index","                nextState = state","                isDone = true","            }","            state = nextState","        }","","        \/\/\/ TBD","        return nil","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-02-03","type":"file","fileType":"swift","highlights":[{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137}]},"doc://PacketProcessor/documentation/PacketProcessor/PacketProcessor":{"role":"symbol","title":"PacketProcessor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"PacketProcessor"}],"abstract":[{"type":"text","text":"Provides a simple, type-safe way of handling structured packets given a data stream."}],"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/PacketProcessor","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PacketProcessor"}],"url":"\/documentation\/packetprocessor\/packetprocessor"},"datapacket-utf8-02-04":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/\/ A buffer to append valid converted `String`s until we're ready to return","        var string = \"\"","","        \/\/\/ The last `Data.Index` that was converted to string","        var lastConsumedIndex: Data.Index!","","        \/\/\/ Invalid bytes found will generate a UTF-8 Replacement character","        let invalidCharacter = \"�\"","","        \/\/\/ A container to keep track of a range of indexes into `Data`","        struct Range {","            let startIndex: Data.Index","            let endIndex: Data.Index","","            init(startIndex: Data.Index, endIndex: Data.Index) {","                self.startIndex = startIndex","                self.endIndex = endIndex","            }","","            init(index: Data.Index) {","                self.startIndex = index","                self.endIndex = index","            }","","            func incrementEnd() -> Range {","                return Range(startIndex: self.startIndex, endIndex: self.endIndex+1)","            }","        }","        enum State {","            \/\/\/ range keeps track of a run of \"good\" bytes that can be converted and appended to ``string``","            case good(range: Range)","","            \/\/\/ goodRange is the last \"good\" range that has not yet been appended to ``string``.","            \/\/\/ partialRange keeps track of the start and current index of a multi-byte character","            case partial(goodRange: Range, partialRange: Range, count: Int)","","            \/\/\/ an exit condition if we were expecting more bytes in a multi-byte character, but ran out","            case incomplete(lastGoodIndex: Data.Index)","","            \/\/\/ an exit condition when everything has been properly converted","            case done(lastGoodIndex: Data.Index)","        }","","        var state = State.good(range: .init(index: data.startIndex))","        var isDone = false","","        while !isDone {","            let nextState: State","            switch state {","            case .good(range: let range):","                \/\/ The logic here is:","                \/\/ - Extend the range while we have valid bytes","                \/\/ - Handle invalid characters","                \/\/ - Move to the `partial` state when we detect a multi-byte character","                \/\/ - Convert validated bytes if we reach the end of the buffer","                guard range.endIndex < data.endIndex else {","                    if range.startIndex < range.endIndex {","                        let goodData = data[range.startIndex..<data.endIndex]","                        string.append(String(data: goodData, encoding: .utf8)!)","                    }","                    nextState = .done(lastGoodIndex: data.endIndex)","                    break","                }","                let byte = data[range.endIndex]","                let nextIndex = range.endIndex + 1","                if (byte & 0b1000_0000) == 0b0000_0000 {","                    nextState = .good(range: range.incrementEnd())","                } else if (byte & 0b1110_0000) == 0b1100_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 1)","                } else if (byte & 0b1111_0000) == 0b1110_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 2)","                } else if (byte & 0b1111_1000) == 0b1111_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 3)","                } else if (byte & 0b1111_1100) == 0b1111_1000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 4)","                } else if (byte & 0b1111_1110) == 0b1111_1100 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 5)","                } else {","                    let goodData = data[range.startIndex..<range.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: nextIndex))","                }","            case .partial(goodRange: let goodRange, partialRange: let partialRange, count: let count):","                \/\/ The logic here is:","                \/\/ - Validate each byte in a multi-byte character","                \/\/ - Handle invalid characters","                \/\/ - Go to `incomplete` state if we have fewer bytes than expected","                \/\/ - Go to `good` state if we've validated all the bytes of the multi-byte character","","                guard count > 0 else {","                    nextState = .good(range: Range(startIndex: goodRange.startIndex, endIndex: partialRange.endIndex))","                    break","                }","                guard partialRange.endIndex < data.endIndex else {","                    nextState = .incomplete(lastGoodIndex: partialRange.startIndex-1)","                    break","                }","                let byte = data[partialRange.endIndex]","                if (byte & 0b1100_0000) == 0b1000_0000 {","                    nextState = .partial(goodRange: goodRange, partialRange: partialRange.incrementEnd(), count: count-1)","                } else {","                    let goodData = data[goodRange.startIndex..<goodRange.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: partialRange.endIndex+1))","                }","            case .incomplete(lastGoodIndex: let index):","                if context.isEnded {","                    string.append(invalidCharacter)","                    lastConsumedIndex = data.endIndex","                } else {","                    lastConsumedIndex = index","                }","                nextState = state","                isDone = true","            case .done(lastGoodIndex: let index):","                lastConsumedIndex = index","                nextState = state","                isDone = true","            }","            state = nextState","        }","","        \/\/\/ TBD","        return nil","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-02-04","type":"file","fileType":"swift","highlights":[{"line":107},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131}]},"datapacket-utf8-02-02":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/\/ A buffer to append valid converted `String`s until we're ready to return","        var string = \"\"","","        \/\/\/ The last `Data.Index` that was converted to string","        var lastConsumedIndex: Data.Index!","","        \/\/\/ Invalid bytes found will generate a UTF-8 Replacement character","        let invalidCharacter = \"�\"","","        \/\/\/ A container to keep track of a range of indexes into `Data`","        struct Range {","            let startIndex: Data.Index","            let endIndex: Data.Index","","            init(startIndex: Data.Index, endIndex: Data.Index) {","                self.startIndex = startIndex","                self.endIndex = endIndex","            }","","            init(index: Data.Index) {","                self.startIndex = index","                self.endIndex = index","            }","","            func incrementEnd() -> Range {","                return Range(startIndex: self.startIndex, endIndex: self.endIndex+1)","            }","        }","","        enum State {","            \/\/\/ range keeps track of a run of \"good\" bytes that can be converted and appended to ``string``","            case good(range: Range)","","            \/\/\/ goodRange is the last \"good\" range that has not yet been appended to ``string``.","            \/\/\/ partialRange keeps track of the start and current index of a multi-byte character","            case partial(goodRange: Range, partialRange: Range, count: Int)","","            \/\/\/ an exit condition if we were expecting more bytes in a multi-byte character, but ran out","            case incomplete(lastGoodIndex: Data.Index)","","            \/\/\/ an exit condition when everything has been properly converted","            case done(lastGoodIndex: Data.Index)","        }","","        \/\/\/ TBD","        return nil","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-02-02","type":"file","fileType":"swift","highlights":[{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61}]},"doc://PacketProcessor/tutorials/Tutorial-TOC":{"role":"overview","title":"Examples Packets","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" can help you to easily convert a stream of characters to structured data packets."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","kind":"overview","type":"topic","url":"\/tutorials\/tutorial-toc"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON":{"role":"project","title":"Reading JSON packets from a socket","estimatedTime":"10min","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/stringpacket-json"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile":{"role":"project","title":"Line oriented String Packets","estimatedTime":"5min","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/stringpacket-logfile"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON#WebSocket":{"role":"pseudoSymbol","title":"WebSocket","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#WebSocket","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-json#WebSocket"},"doc://PacketProcessor/tutorials/Tutorial-TOC/Processing-messages-from-sockets":{"role":"article","title":"Processing messages from sockets","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Processing-messages-from-sockets","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/processing-messages-from-sockets"},"doc://PacketProcessor/tutorials/Tutorial-TOC/Converting-UTF-8-byte-streams-to-Strings":{"role":"article","title":"Converting UTF-8 byte streams to Strings","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Converting-UTF-8-byte-streams-to-Strings","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/converting-utf-8-byte-streams-to-strings"},"datapacket-utf8-02-05":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/\/ A buffer to append valid converted `String`s until we're ready to return","        var string = \"\"","","        \/\/\/ The last `Data.Index` that was converted to string","        var lastConsumedIndex: Data.Index!","","        \/\/\/ Invalid bytes found will generate a UTF-8 Replacement character","        let invalidCharacter = \"�\"","","        \/\/\/ A container to keep track of a range of indexes into `Data`","        struct Range {","            let startIndex: Data.Index","            let endIndex: Data.Index","","            init(startIndex: Data.Index, endIndex: Data.Index) {","                self.startIndex = startIndex","                self.endIndex = endIndex","            }","","            init(index: Data.Index) {","                self.startIndex = index","                self.endIndex = index","            }","","            func incrementEnd() -> Range {","                return Range(startIndex: self.startIndex, endIndex: self.endIndex+1)","            }","        }","        enum State {","            \/\/\/ range keeps track of a run of \"good\" bytes that can be converted and appended to ``string``","            case good(range: Range)","","            \/\/\/ goodRange is the last \"good\" range that has not yet been appended to ``string``.","            \/\/\/ partialRange keeps track of the start and current index of a multi-byte character","            case partial(goodRange: Range, partialRange: Range, count: Int)","","            \/\/\/ an exit condition if we were expecting more bytes in a multi-byte character, but ran out","            case incomplete(lastGoodIndex: Data.Index)","","            \/\/\/ an exit condition when everything has been properly converted","            case done(lastGoodIndex: Data.Index)","        }","","        var state = State.good(range: .init(index: data.startIndex))","        var isDone = false","","        while !isDone {","            let nextState: State","            switch state {","            case .good(range: let range):","                \/\/ The logic here is:","                \/\/ - Extend the range while we have valid bytes","                \/\/ - Handle invalid characters","                \/\/ - Move to the `partial` state when we detect a multi-byte character","                \/\/ - Convert validated bytes if we reach the end of the buffer","                guard range.endIndex < data.endIndex else {","                    if range.startIndex < range.endIndex {","                        let goodData = data[range.startIndex..<data.endIndex]","                        string.append(String(data: goodData, encoding: .utf8)!)","                    }","                    nextState = .done(lastGoodIndex: data.endIndex)","                    break","                }","                let byte = data[range.endIndex]","                let nextIndex = range.endIndex + 1","                if (byte & 0b1000_0000) == 0b0000_0000 {","                    nextState = .good(range: range.incrementEnd())","                } else if (byte & 0b1110_0000) == 0b1100_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 1)","                } else if (byte & 0b1111_0000) == 0b1110_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 2)","                } else if (byte & 0b1111_1000) == 0b1111_0000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 3)","                } else if (byte & 0b1111_1100) == 0b1111_1000 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 4)","                } else if (byte & 0b1111_1110) == 0b1111_1100 {","                    nextState = .partial(goodRange: range, partialRange: .init(index: nextIndex), count: 5)","                } else {","                    let goodData = data[range.startIndex..<range.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: nextIndex))","                }","            case .partial(goodRange: let goodRange, partialRange: let partialRange, count: let count):","                \/\/ The logic here is:","                \/\/ - Validate each byte in a multi-byte character","                \/\/ - Handle invalid characters","                \/\/ - Go to `incomplete` state if we have fewer bytes than expected","                \/\/ - Go to `good` state if we've validated all the bytes of the multi-byte character","","                guard count > 0 else {","                    nextState = .good(range: Range(startIndex: goodRange.startIndex, endIndex: partialRange.endIndex))","                    break","                }","                guard partialRange.endIndex < data.endIndex else {","                    nextState = .incomplete(lastGoodIndex: partialRange.startIndex-1)","                    break","                }","                let byte = data[partialRange.endIndex]","                if (byte & 0b1100_0000) == 0b1000_0000 {","                    nextState = .partial(goodRange: goodRange, partialRange: partialRange.incrementEnd(), count: count-1)","                } else {","                    let goodData = data[goodRange.startIndex..<goodRange.endIndex]","                    string.append(String(data: goodData, encoding: .utf8)!)","                    string.append(invalidCharacter)","                    nextState = .good(range: .init(index: partialRange.endIndex+1))","                }","            case .incomplete(lastGoodIndex: let index):","                if context.isEnded {","                    string.append(invalidCharacter)","                    lastConsumedIndex = data.endIndex","                } else {","                    lastConsumedIndex = index","                }","                nextState = state","                isDone = true","            case .done(lastGoodIndex: let index):","                lastConsumedIndex = index","                nextState = state","                isDone = true","            }","            state = nextState","        }","","        if string.count > 0 {","            let packet = UTF8ToString(string: string)","            let numberOfBytes = lastConsumedIndex - data.startIndex","            return PacketSearchResult(packet: packet,","                                      numberOfElementsConsumedByPacket: numberOfBytes)","        } else {","            return nil","        }","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-02-05","type":"file","fileType":"swift","highlights":[{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149}]},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile#Setup-the-Packet-Processor":{"role":"pseudoSymbol","title":"Setup the Packet Processor","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Setup-the-Packet-Processor","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-logfile#Setup-the-Packet-Processor"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8":{"role":"project","title":"UTF-8 to String Converter","estimatedTime":"15min","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/datapacket-utf8"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON#Raw-sockets":{"role":"pseudoSymbol","title":"Raw sockets","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#Raw-sockets","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-json#Raw-sockets"},"datapacket-utf8-01-01":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A simple UTF-8 decoder","","Created by Danny Sung on 05\/05\/2022.","*\/","","","import Foundation","","struct UTF8ToString: DataPacket {","    var string: String","","    static var _packetTypeId = UUID()","","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<UTF8ToString>? {","        \/\/ TBD","    }","}"],"fileName":"UTF8ToString.swift","identifier":"datapacket-utf8-01-01","type":"file","fileType":"swift","highlights":[]}}}