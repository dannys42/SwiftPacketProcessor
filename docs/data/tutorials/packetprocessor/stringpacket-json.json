{"metadata":{"title":"Reading JSON packets from a socket","categoryPathComponent":"Tutorial-TOC","role":"project","category":"Tutorials"},"hierarchy":{"modules":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Reading-log-files","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Define-the-Packet"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Setup-the-Packet-Processor"}]}]},{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Processing-messages-from-sockets","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#WebSocket"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#Raw-sockets"}]}]},{"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Converting-UTF-8-byte-streams-to-Strings","projects":[{"reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","sections":[{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#The-naive-way"},{"kind":"task","reference":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#Processing-a-stream"}]}]}],"reference":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","paths":[["doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/$volume","doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Processing-messages-from-sockets"]]},"schemaVersion":{"major":0,"minor":2,"patch":0},"kind":"project","identifier":{"url":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON","interfaceLanguage":"swift"},"sections":[{"kind":"hero","title":"Reading JSON packets from a socket","chapter":"Processing messages from sockets","estimatedTimeInMinutes":10,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}]}]},{"kind":"tasks","tasks":[{"anchor":"WebSocket","title":"WebSocket","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Since WebSockets are gauranteed to include the entire message upon read, very little is needed to support them."}]}],"mediaPosition":"trailing"}],"stepsSection":[{"code":"stringpacket-json-01-01","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose we have the following JSON objects coming in from a streasm"}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"stringpacket-json-01-02","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We start out defining our structs."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"stringpacket-json-01-03","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In the case of WebSockets, we can make due without "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" by simply attempting to decode our packets in turn."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"stringpacket-json-01-04","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Alternatively we could use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":"."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]},{"anchor":"Raw-sockets","title":"Raw sockets","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Raw sockets can be a little trickier to work with since messages can be split anywhere.  This is where "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" can help simplify things a little."}]}],"mediaPosition":"trailing"}],"stepsSection":[{"code":"stringpacket-json-02-01","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"First we need a way to buffer and split messages at the JSON message boundary.  This is a simple state machine that does just that.  It assumes every message is a dictionary."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"stringpacket-json-02-02","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we have that, we’re back in a similar situation as the WebSocket.  We can decode the JSON messages directly."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null},{"code":"stringpacket-json-02-03","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Or we can define each JSON object as their own "},{"type":"codeVoice","code":"DataPacket"},{"type":"text","text":" and handle it with a two-stage "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/PacketProcessor"},{"type":"text","text":"."}]}],"caption":[],"type":"step","runtimePreview":null,"media":null}]}]},{"action":{"overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"isActive":true,"type":"reference","identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","kind":"callToAction","title":"UTF-8 to String Converter","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}]}],"references":{"stringpacket-json-01-03":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct Coordinates: Codable {","    let x: Int","    let y: Int","}","","struct PlayerMove: Codable {","    let playerId: Int","    let move: Coordinates","}","","struct PlayerAttack: Codable {","    let playerId: Int","    let attack: Coordinates","    let weapon: String","}","","func handleNewData(packetData: Data) {","    if let playerMove = try? jsonDecoder.decode(PlayerMove.self, from: packetData) {","        \/\/ handle move","    } else if let playerAttack = try? jsonDecoder.decode(PlayerAttack.self, from: packetData) {","        \/\/ handle attack","    }","}"],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-01-03","type":"file","fileType":"swift","highlights":[{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}]},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON#Raw-sockets":{"role":"pseudoSymbol","title":"Raw sockets","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#Raw-sockets","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-json#Raw-sockets"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile#Setup-the-Packet-Processor":{"role":"pseudoSymbol","title":"Setup the Packet Processor","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Setup-the-Packet-Processor","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-logfile#Setup-the-Packet-Processor"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8":{"role":"project","title":"UTF-8 to String Converter","estimatedTime":"15min","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/datapacket-utf8"},"stringpacket-json-01-04":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct Coordinates: Codable {","    let x: Int","    let y: Int","}","","struct PlayerMove: Codable {","    let playerId: Int","    let move: Coordinates","}","","struct PlayerAttack: Codable {","    let playerId: Int","    let attack: Coordinates","    let weapon: String","}","","\/\/ Setup","let packetProcessor = PacketProcessor<Data>()","","packetProcessor.addHandler(PlayerMovePacket.self) { packet in","    playerMove = packet","}","packetProcessor.addHandler(PlayerAttackPacket.self) { packet in","    playerAttack = packet","}","","\/\/ Read new packets","let newData = ...","packetProcessor.push(newData)"],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-01-04","type":"file","fileType":"swift","highlights":[{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}]},"doc://PacketProcessor/tutorials/Tutorial-TOC/Processing-messages-from-sockets":{"role":"article","title":"Processing messages from sockets","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Processing-messages-from-sockets","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/processing-messages-from-sockets"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8#Processing-a-stream":{"role":"pseudoSymbol","title":"Processing a stream","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#Processing-a-stream","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/datapacket-utf8#Processing-a-stream"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON":{"role":"project","title":"Reading JSON packets from a socket","estimatedTime":"10min","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/stringpacket-json"},"stringpacket-json-02-01":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct JSONPacket: StringPacket {","    var value: String","","    static var _packetTypeId = UUID()","    static func findFirstPacket(context: PacketHandlerContext, data: String) -> PacketSearchResult<JSONPacketTests.JSONPacket>? {","","        var objectLevel = 0","        enum State {","            case unquoted","            case quoted","            case quotedEscape","        }","        var state = State.unquoted","        var numberOfCharactersConsumed: Int?","","        for (index,character) in data.enumerated() {","            if numberOfCharactersConsumed != nil {","                break","            }","            if character.isWhitespace { \/\/ ignore whitespace","                continue","            }","            var nextState: State","            switch state {","            case .unquoted:","                \/\/ Try to find out where the object boundary is","                switch character {","                case \"{\":","                    objectLevel += 1","                    nextState = state","                case \"}\":","                    objectLevel -= 1","                    if objectLevel == 0 {","                        numberOfCharactersConsumed = index + 1","                    }","                    nextState = state","                case \"\\\"\":","                    nextState = .quoted","                default:","                    nextState = state","                }","            case .quoted:","                \/\/ Once we're inside double-quotes, just keep going until we're no longer quoted, paying attention to escape characters.","                switch character {","                case \"\\\"\":","                    nextState = .unquoted","                case \"\\\\\":","                    nextState = .quotedEscape","                default:","                    nextState = state","                }","            case .quotedEscape:","                \/\/ It actually doesn't matter what this character is.  We'll simply go back to the quoted state.","                nextState = .quoted","            }","            state = nextState","        }","","        if let numberOfCharactersConsumed = numberOfCharactersConsumed {","            let packet = JSONPacket(value: String(data.prefix(numberOfCharactersConsumed)))","            return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: numberOfCharactersConsumed)","        }","        return nil","    }","}",""],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-02-01","type":"file","fileType":"swift","highlights":[]},"stringpacket-json-01-02":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct Coordinates: Codable {","    let x: Int","    let y: Int","}","","struct PlayerMove: Codable {","    let playerId: Int","    let move: Coordinates","}","","struct PlayerAttack: Codable {","    let playerId: Int","    let attack: Coordinates","    let weapon: String","}"],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-01-02","type":"file","fileType":"swift","highlights":[]},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-JSON#WebSocket":{"role":"pseudoSymbol","title":"WebSocket","abstract":[{"type":"text","text":"This example demonstrates how we can use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" to manage different JSON packets read from a WebSocket or raw socket."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-JSON#WebSocket","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-json#WebSocket"},"doc://PacketProcessor/documentation/PacketProcessor":{"role":"collection","title":"PacketProcessor","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" takes care of buffer management when processing packetized data within streams."}],"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor","kind":"symbol","type":"topic","url":"\/documentation\/packetprocessor"},"stringpacket-json-02-03":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct JSONPacket: StringPacket {","    var value: String","","    static var _packetTypeId = UUID()","    static func findFirstPacket(context: PacketHandlerContext, data: String) -> PacketSearchResult<JSONPacketTests.JSONPacket>? {","","        var objectLevel = 0","        enum State {","            case unquoted","            case quoted","            case quotedEscape","        }","        var state = State.unquoted","        var numberOfCharactersConsumed: Int?","","        for (index,character) in data.enumerated() {","            if numberOfCharactersConsumed != nil {","                break","            }","            if character.isWhitespace { \/\/ ignore whitespace","                continue","            }","            var nextState: State","            switch state {","            case .unquoted:","                \/\/ Try to find out where the object boundary is","                switch character {","                case \"{\":","                    objectLevel += 1","                    nextState = state","                case \"}\":","                    objectLevel -= 1","                    if objectLevel == 0 {","                        numberOfCharactersConsumed = index + 1","                    }","                    nextState = state","                case \"\\\"\":","                    nextState = .quoted","                default:","                    nextState = state","                }","            case .quoted:","                \/\/ Once we're inside double-quotes, just keep going until we're no longer quoted, paying attention to escape characters.","                switch character {","                case \"\\\"\":","                    nextState = .unquoted","                case \"\\\\\":","                    nextState = .quotedEscape","                default:","                    nextState = state","                }","            case .quotedEscape:","                \/\/ It actually doesn't matter what this character is.  We'll simply go back to the quoted state.","                nextState = .quoted","            }","            state = nextState","        }","","        if let numberOfCharactersConsumed = numberOfCharactersConsumed {","            let packet = JSONPacket(value: String(data.prefix(numberOfCharactersConsumed)))","            return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: numberOfCharactersConsumed)","        }","        return nil","    }","}","","struct PlayerMove: Codable, DataPacket {","    let playerId: Int","    let move: Coordinates","","    static var _packetTypeId = UUID()","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<JSONPacketTests.PlayerMovePacket>? {","","        let decoder = JSONDecoder()","        if let packet = try? decoder.decode(PlayerMovePacket.self, from: data) {","            return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: data.count)","        }","","        return nil","    }","}","","struct PlayerAttack: Codable, DataPacket {","    let playerId: Int","    let attack: Coordinates","    let weapon: String","","    static var _packetTypeId = UUID()","    static func findFirstPacket(context: PacketHandlerContext, data: Data) -> PacketSearchResult<JSONPacketTests.PlayerAttackPacket>? {","","        let decoder = JSONDecoder()","        if let packet = try? decoder.decode(PlayerAttackPacket.self, from: data) {","            return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: data.count)","        }","","        return nil","    }","}","","","let jsonProcessor = PacketProcessor<String>()","let packetProcessor = PacketProcessor<Data>()","","jsonProcessor.addHandler(JSONPacket.self) { packet in","    let packetData = packet.value.data(using: .utf8)!","    packetProcessor.push(packetData)","}","","packetProcessor.addHandler(PlayerMove.self) { packet in","    \/\/ Handle move","}","","packetProcessor.addHandler(PlayerAttack.self) { packet in","    \/\/ Handle attack","}"],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-02-03","type":"file","fileType":"swift","highlights":[{"line":78},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":94},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":111},{"line":113},{"line":117},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126}]},"doc://PacketProcessor/tutorials/Tutorial-TOC/Converting-UTF-8-byte-streams-to-Strings":{"role":"article","title":"Converting UTF-8 byte streams to Strings","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Converting-UTF-8-byte-streams-to-Strings","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/converting-utf-8-byte-streams-to-strings"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile":{"role":"project","title":"Line oriented String Packets","estimatedTime":"5min","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile","kind":"project","type":"topic","url":"\/tutorials\/packetprocessor\/stringpacket-logfile"},"doc://PacketProcessor/tutorials/PacketProcessor/DataPacket-utf8#The-naive-way":{"role":"pseudoSymbol","title":"The naive way","abstract":[{"type":"text","text":"The standard approach to UTF-8 conversion is to load all UTF-8 data into a "},{"type":"codeVoice","code":"Data()"},{"type":"text","text":" object, then convert to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" using "},{"type":"codeVoice","code":"String(data:utf8)"},{"type":"text","text":".  While this works, it can be problematic in a couple areas:"}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/DataPacket-utf8#The-naive-way","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/datapacket-utf8#The-naive-way"},"doc://PacketProcessor/tutorials/Tutorial-TOC":{"role":"overview","title":"Examples Packets","abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor"},{"type":"text","text":" can help you to easily convert a stream of characters to structured data packets."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC","kind":"overview","type":"topic","url":"\/tutorials\/tutorial-toc"},"doc://PacketProcessor/tutorials/PacketProcessor/StringPacket-Logfile#Define-the-Packet":{"role":"pseudoSymbol","title":"Define the Packet","abstract":[{"type":"text","text":"A simple variable-length packet for reading lines of text (e.g. from log files)."}],"identifier":"doc:\/\/PacketProcessor\/tutorials\/PacketProcessor\/StringPacket-Logfile#Define-the-Packet","kind":"section","type":"section","url":"\/tutorials\/packetprocessor\/stringpacket-logfile#Define-the-Packet"},"doc://PacketProcessor/tutorials/Tutorial-TOC/Reading-log-files":{"role":"article","title":"Reading log files","abstract":[],"identifier":"doc:\/\/PacketProcessor\/tutorials\/Tutorial-TOC\/Reading-log-files","kind":"article","type":"topic","url":"\/tutorials\/tutorial-toc\/reading-log-files"},"doc://PacketProcessor/documentation/PacketProcessor/PacketProcessor":{"role":"symbol","title":"PacketProcessor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"PacketProcessor"}],"abstract":[{"type":"text","text":"Provides a simple, type-safe way of handling structured packets given a data stream."}],"identifier":"doc:\/\/PacketProcessor\/documentation\/PacketProcessor\/PacketProcessor","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PacketProcessor"}],"url":"\/documentation\/packetprocessor\/packetprocessor"},"stringpacket-json-01-01":{"syntax":"json","content":["{","    \"playerId\": 1,","    \"move\": {","        \"x\" : 3,","        \"y\" : 2","}","","{","    \"playerId\": 1,","    \"attack\": {","        \"x\" : 7,","        \"y\" : 9","    },","    \"weapon\": \"cannon\"","}"],"fileName":"packets.json","identifier":"stringpacket-json-01-01","type":"file","fileType":"json","highlights":[]},"stringpacket-json-02-02":{"syntax":"swift","content":["\/*","See LICENSE file for this sample’s licensing information.","","Abstract:","A JSON packet processor, supporting multiple types of JSON packets.","","Created by Danny Sung on 05\/07\/2022.","*\/","","import Foundation","","struct JSONPacket: StringPacket {","    var value: String","","    static var _packetTypeId = UUID()","    static func findFirstPacket(context: PacketHandlerContext, data: String) -> PacketSearchResult<JSONPacketTests.JSONPacket>? {","","        var objectLevel = 0","        enum State {","            case unquoted","            case quoted","            case quotedEscape","        }","        var state = State.unquoted","        var numberOfCharactersConsumed: Int?","","        for (index,character) in data.enumerated() {","            if numberOfCharactersConsumed != nil {","                break","            }","            if character.isWhitespace { \/\/ ignore whitespace","                continue","            }","            var nextState: State","            switch state {","            case .unquoted:","                \/\/ Try to find out where the object boundary is","                switch character {","                case \"{\":","                    objectLevel += 1","                    nextState = state","                case \"}\":","                    objectLevel -= 1","                    if objectLevel == 0 {","                        numberOfCharactersConsumed = index + 1","                    }","                    nextState = state","                case \"\\\"\":","                    nextState = .quoted","                default:","                    nextState = state","                }","            case .quoted:","                \/\/ Once we're inside double-quotes, just keep going until we're no longer quoted, paying attention to escape characters.","                switch character {","                case \"\\\"\":","                    nextState = .unquoted","                case \"\\\\\":","                    nextState = .quotedEscape","                default:","                    nextState = state","                }","            case .quotedEscape:","                \/\/ It actually doesn't matter what this character is.  We'll simply go back to the quoted state.","                nextState = .quoted","            }","            state = nextState","        }","","        if let numberOfCharactersConsumed = numberOfCharactersConsumed {","            let packet = JSONPacket(value: String(data.prefix(numberOfCharactersConsumed)))","            return PacketSearchResult(packet: packet, numberOfElementsConsumedByPacket: numberOfCharactersConsumed)","        }","        return nil","    }","}","","struct PlayerMove: Codable {","    let playerId: Int","    let move: Coordinates","}","","struct PlayerAttack: Codable {","    let playerId: Int","    let attack: Coordinates","    let weapon: String","}","","let jsonProcessor = PacketProcessor<String>()","","jsonProcessor.addHandler(JSONPacket.self) { packet in","    let packetData = packet.value.data(using: .utf8)!","    if let playerMove = try? jsonDecoder.decode(PlayerMove.self, from: packetData) {","        \/\/ handle move","    } else if let playerAttack = try? jsonDecoder.decode(PlayerAttack.self, from: packetData) {","        \/\/ handle attack","    }","}"],"fileName":"jsonpacket.swift","identifier":"stringpacket-json-02-02","type":"file","fileType":"swift","highlights":[{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98}]}}}